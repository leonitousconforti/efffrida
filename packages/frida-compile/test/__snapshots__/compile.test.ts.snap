// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`Should compile the agent > conflicting exports agent 1`] = `
"// packages/frida-compile/frida/agent3/another.ts
var A = "another->A";
var B = "another->B";

// packages/frida-compile/frida/agent3/other.ts
var A2 = "other->A";

// packages/frida-compile/frida/agent3/main.ts
console.log("Hello from agent3", A2, A, B);
"
`;

exports[`Should compile the agent > double file agent 1`] = `
"// packages/frida-compile/frida/agent2/other.ts
var A = "other->A";

// packages/frida-compile/frida/agent2/main.ts
console.log("Hello from agent2", A);
"
`;

exports[`Should compile the agent > single file agent 1`] = `
"var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// node_modules/.pnpm/@frida+util@1.0.3/node_modules/@frida/util/support/types.js
var types_exports = {};
__export(types_exports, {
  isAnyArrayBuffer: () => isAnyArrayBuffer,
  isArgumentsObject: () => isArgumentsObject,
  isArrayBuffer: () => isArrayBuffer,
  isArrayBufferView: () => isArrayBufferView,
  isAsyncFunction: () => isAsyncFunction,
  isBigInt64Array: () => isBigInt64Array,
  isBigIntObject: () => isBigIntObject,
  isBigUint64Array: () => isBigUint64Array,
  isBooleanObject: () => isBooleanObject,
  isBoxedPrimitive: () => isBoxedPrimitive,
  isDataView: () => isDataView,
  isExternal: () => isExternal,
  isFloat32Array: () => isFloat32Array,
  isFloat64Array: () => isFloat64Array,
  isGeneratorFunction: () => isGeneratorFunction,
  isGeneratorObject: () => isGeneratorObject,
  isInt16Array: () => isInt16Array,
  isInt32Array: () => isInt32Array,
  isInt8Array: () => isInt8Array,
  isMap: () => isMap,
  isMapIterator: () => isMapIterator,
  isModuleNamespaceObject: () => isModuleNamespaceObject,
  isNumberObject: () => isNumberObject,
  isPromise: () => isPromise,
  isProxy: () => isProxy,
  isSet: () => isSet,
  isSetIterator: () => isSetIterator,
  isSharedArrayBuffer: () => isSharedArrayBuffer,
  isStringObject: () => isStringObject,
  isSymbolObject: () => isSymbolObject,
  isTypedArray: () => isTypedArray,
  isUint16Array: () => isUint16Array,
  isUint32Array: () => isUint32Array,
  isUint8Array: () => isUint8Array,
  isUint8ClampedArray: () => isUint8ClampedArray,
  isWeakMap: () => isWeakMap,
  isWeakSet: () => isWeakSet,
  isWebAssemblyCompiledModule: () => isWebAssemblyCompiledModule
});
var ObjectToString = uncurryThis(Object.prototype.toString);
var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);
var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
var symbolValue = uncurryThis(Symbol.prototype.valueOf);
var generatorPrototype = Object.getPrototypeOf(function* () {
});
var typedArrayPrototype = Object.getPrototypeOf(Int8Array);
function isArgumentsObject(value) {
  if (value !== null && typeof value === "object" && Symbol.toStringTag in value) {
    return false;
  }
  return ObjectToString(value) === "[object Arguments]";
}
function isGeneratorFunction(value) {
  return Object.getPrototypeOf(value) === generatorPrototype;
}
function isTypedArray(value) {
  return value instanceof typedArrayPrototype;
}
function isPromise(input) {
  return input instanceof Promise;
}
function isArrayBufferView(value) {
  return ArrayBuffer.isView(value);
}
function isUint8Array(value) {
  return value instanceof Uint8Array;
}
function isUint8ClampedArray(value) {
  return value instanceof Uint8ClampedArray;
}
function isUint16Array(value) {
  return value instanceof Uint16Array;
}
function isUint32Array(value) {
  return value instanceof Uint32Array;
}
function isInt8Array(value) {
  return value instanceof Int8Array;
}
function isInt16Array(value) {
  return value instanceof Int16Array;
}
function isInt32Array(value) {
  return value instanceof Int32Array;
}
function isFloat32Array(value) {
  return value instanceof Float32Array;
}
function isFloat64Array(value) {
  return value instanceof Float64Array;
}
function isBigInt64Array(value) {
  return value instanceof BigInt64Array;
}
function isBigUint64Array(value) {
  return value instanceof BigUint64Array;
}
function isMap(value) {
  return ObjectToString(value) === "[object Map]";
}
function isSet(value) {
  return ObjectToString(value) === "[object Set]";
}
function isWeakMap(value) {
  return ObjectToString(value) === "[object WeakMap]";
}
function isWeakSet(value) {
  return ObjectToString(value) === "[object WeakSet]";
}
function isArrayBuffer(value) {
  return ObjectToString(value) === "[object ArrayBuffer]";
}
function isDataView(value) {
  return ObjectToString(value) === "[object DataView]";
}
function isSharedArrayBuffer(value) {
  return ObjectToString(value) === "[object SharedArrayBuffer]";
}
function isAsyncFunction(value) {
  return ObjectToString(value) === "[object AsyncFunction]";
}
function isMapIterator(value) {
  return ObjectToString(value) === "[object Map Iterator]";
}
function isSetIterator(value) {
  return ObjectToString(value) === "[object Set Iterator]";
}
function isGeneratorObject(value) {
  return ObjectToString(value) === "[object Generator]";
}
function isWebAssemblyCompiledModule(value) {
  return ObjectToString(value) === "[object WebAssembly.Module]";
}
function isNumberObject(value) {
  return checkBoxedPrimitive(value, numberValue);
}
function isStringObject(value) {
  return checkBoxedPrimitive(value, stringValue);
}
function isBooleanObject(value) {
  return checkBoxedPrimitive(value, booleanValue);
}
function isBigIntObject(value) {
  return checkBoxedPrimitive(value, bigIntValue);
}
function isSymbolObject(value) {
  return checkBoxedPrimitive(value, symbolValue);
}
function checkBoxedPrimitive(value, prototypeValueOf) {
  if (typeof value !== "object") {
    return false;
  }
  try {
    prototypeValueOf(value);
    return true;
  } catch (e) {
    return false;
  }
}
function isBoxedPrimitive(value) {
  return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
}
function isAnyArrayBuffer(value) {
  return isArrayBuffer(value) || isSharedArrayBuffer(value);
}
function isProxy(value) {
  throwNotSupported("isProxy");
}
function isExternal(value) {
  throwNotSupported("isExternal");
}
function isModuleNamespaceObject(value) {
  throwNotSupported("isModuleNamespaceObject");
}
function throwNotSupported(method) {
  throw new Error(\`\${method} is not supported in userland\`);
}
function uncurryThis(f) {
  return f.call.bind(f);
}

// node_modules/.pnpm/@frida+process@1.2.1/node_modules/@frida/process/index.js
function nextTick(callback, ...args) {
  Script.nextTick(callback, ...args);
}
var title = "Frida";
var browser = false;
var platform = detectPlatform();
var pid = Process.id;
var env = {
  FRIDA_COMPILE: "1"
};
var argv = [];
var version = Frida.version;
var versions = {};
function noop() {
}
var on = noop;
var addListener = noop;
var once = noop;
var off = noop;
var removeListener = noop;
var removeAllListeners = noop;
var emit = noop;
var prependListener = noop;
var prependOnceListener = noop;
var listeners = function(name) {
  return [];
};
function binding(name) {
  throw new Error("process.binding is not supported");
}
function cwd() {
  return Process.platform === "windows" ? "C:\\\\" : "/";
}
function chdir(dir) {
  throw new Error("process.chdir is not supported");
}
function umask() {
  return 0;
}
var process_default = {
  nextTick,
  title,
  browser,
  platform,
  pid,
  env,
  argv,
  version,
  versions,
  on,
  addListener,
  once,
  off,
  removeListener,
  removeAllListeners,
  emit,
  prependListener,
  prependOnceListener,
  listeners,
  binding,
  cwd,
  chdir,
  umask
};
function detectPlatform() {
  const platform2 = Process.platform;
  return platform2 === "windows" ? "win32" : platform2;
}

// node_modules/.pnpm/@frida+util@1.0.3/node_modules/@frida/util/util.js
var types = {
  ...types_exports,
  isRegExp,
  isDate,
  isNativeError: isError
};
var util_default = {
  format,
  deprecate,
  debuglog,
  inspect,
  types,
  isArray,
  isBoolean,
  isNull,
  isNullOrUndefined,
  isNumber,
  isString,
  isSymbol,
  isUndefined,
  isRegExp,
  isObject,
  isDate,
  isError,
  isFunction,
  isPrimitive,
  isBuffer,
  log,
  inherits,
  _extend,
  promisify,
  callbackify
};
var formatRegExp = /%[sdj%]/g;
function format(f) {
  if (!isString(f)) {
    const objects = [];
    for (let i2 = 0; i2 < arguments.length; i2++) {
      objects.push(inspect(arguments[i2]));
    }
    return objects.join(" ");
  }
  let i = 1;
  const args = arguments;
  const len = args.length;
  let str = String(f).replace(formatRegExp, function(x) {
    if (x === "%%") return "%";
    if (i >= len) return x;
    switch (x) {
      case "%s":
        return String(args[i++]);
      case "%d":
        return Number(args[i++]);
      case "%j":
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return "[Circular]";
        }
      default:
        return x;
    }
  });
  for (let x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += " " + x;
    } else {
      str += " " + inspect(x);
    }
  }
  return str;
}
function deprecate(fn, msg) {
  if (process_default.noDeprecation === true) {
    return fn;
  }
  let warned2 = false;
  function deprecated() {
    if (!warned2) {
      if (process_default.throwDeprecation) {
        throw new Error(msg);
      } else if (process_default.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned2 = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
var debugs = {};
var debugEnvRegex = /^$/;
if (process_default.env.NODE_DEBUG) {
  let debugEnv = process_default.env.NODE_DEBUG;
  debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+?.]/g, "\\\\$&").replace(/\\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
  debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
}
function debuglog(set) {
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (debugEnvRegex.test(set)) {
      const pid2 = process_default.pid;
      debugs[set] = function() {
        const msg = format.apply(null, arguments);
        console.error("%s %d: %s", set, pid2, msg);
      };
    } else {
      debugs[set] = function() {
      };
    }
  }
  return debugs[set];
}
function inspect(obj, opts) {
  const ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    ctx.showHidden = opts;
  } else if (opts) {
    _extend(ctx, opts);
  }
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
inspect.custom = Symbol.for("nodejs.util.inspect.custom");
inspect.colors = {
  "bold": [1, 22],
  "italic": [3, 23],
  "underline": [4, 24],
  "inverse": [7, 27],
  "white": [37, 39],
  "grey": [90, 39],
  "black": [30, 39],
  "blue": [34, 39],
  "cyan": [36, 39],
  "green": [32, 39],
  "magenta": [35, 39],
  "red": [31, 39],
  "yellow": [33, 39]
};
inspect.styles = {
  "special": "cyan",
  "number": "yellow",
  "boolean": "yellow",
  "undefined": "grey",
  "null": "bold",
  "string": "green",
  "date": "magenta",
  // "name": intentionally not styling
  "regexp": "red"
};
function stylizeWithColor(str, styleType) {
  const style = inspect.styles[styleType];
  if (style) {
    return "\\x1B[" + inspect.colors[style][0] + "m" + str + "\\x1B[" + inspect.colors[style][1] + "m";
  } else {
    return str;
  }
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array) {
  const hash = {};
  array.forEach(function(val, idx) {
    hash[val] = true;
  });
  return hash;
}
function formatValue(ctx, value, recurseTimes) {
  if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
  value.inspect !== inspect && // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    let ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }
  const primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }
  let keys = Object.keys(value);
  const visibleKeys = arrayToHash(keys);
  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }
  if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
    return formatError(value);
  }
  if (keys.length === 0) {
    if (isFunction(value)) {
      const name = value.name ? ": " + value.name : "";
      return ctx.stylize("[Function" + name + "]", "special");
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), "date");
    }
    if (isError(value)) {
      return formatError(value);
    }
  }
  let base = "", array = false, braces = ["{", "}"];
  if (isArray(value)) {
    array = true;
    braces = ["[", "]"];
  }
  if (isFunction(value)) {
    const n = value.name ? ": " + value.name : "";
    base = " [Function" + n + "]";
  }
  if (isRegExp(value)) {
    base = " " + RegExp.prototype.toString.call(value);
  }
  if (isDate(value)) {
    base = " " + Date.prototype.toUTCString.call(value);
  }
  if (isError(value)) {
    base = " " + formatError(value);
  }
  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    } else {
      return ctx.stylize("[Object]", "special");
    }
  }
  ctx.seen.push(value);
  let output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize("undefined", "undefined");
  if (isString(value)) {
    const simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\\\'").replace(/\\\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber(value))
    return ctx.stylize("" + value, "number");
  if (isBoolean(value))
    return ctx.stylize("" + value, "boolean");
  if (isNull(value))
    return ctx.stylize("null", "null");
}
function formatError(value) {
  return "[" + Error.prototype.toString.call(value) + "]";
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  const output = [];
  for (let i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(
        ctx,
        value,
        recurseTimes,
        visibleKeys,
        String(i),
        true
      ));
    } else {
      output.push("");
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\\d+$/)) {
      output.push(formatProperty(
        ctx,
        value,
        recurseTimes,
        visibleKeys,
        key,
        true
      ));
    }
  });
  return output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  let name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize("[Getter/Setter]", "special");
    } else {
      str = ctx.stylize("[Getter]", "special");
    }
  } else {
    if (desc.set) {
      str = ctx.stylize("[Setter]", "special");
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = "[" + key + "]";
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf("\\n") > -1) {
        if (array) {
          str = str.split("\\n").map(function(line) {
            return "  " + line;
          }).join("\\n").substr(2);
        } else {
          str = "\\n" + str.split("\\n").map(function(line) {
            return "   " + line;
          }).join("\\n");
        }
      }
    } else {
      str = ctx.stylize("[Circular]", "special");
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\\d+$/)) {
      return str;
    }
    name = JSON.stringify("" + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, "name");
    } else {
      name = name.replace(/'/g, "\\\\'").replace(/\\\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, "string");
    }
  }
  return name + ": " + str;
}
function reduceToSingleString(output, base, braces) {
  const length = output.reduce(function(prev, cur) {
    if (cur.indexOf("\\n") >= 0) ;
    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, "").length + 1;
  }, 0);
  if (length > 60) {
    return braces[0] + (base === "" ? "" : base + "\\n ") + " " + output.join(",\\n  ") + " " + braces[1];
  }
  return braces[0] + base + " " + output.join(", ") + " " + braces[1];
}
function isArray(ar) {
  return Array.isArray(ar);
}
function isBoolean(arg) {
  return typeof arg === "boolean";
}
function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return arg == null;
}
function isNumber(arg) {
  return typeof arg === "number";
}
function isString(arg) {
  return typeof arg === "string";
}
function isSymbol(arg) {
  return typeof arg === "symbol";
}
function isUndefined(arg) {
  return arg === void 0;
}
function isRegExp(re) {
  return isObject(re) && objectToString(re) === "[object RegExp]";
}
function isObject(arg) {
  return typeof arg === "object" && arg !== null;
}
function isDate(d) {
  return isObject(d) && objectToString(d) === "[object Date]";
}
function isError(e) {
  return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
}
function isFunction(arg) {
  return typeof arg === "function";
}
function isPrimitive(arg) {
  return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
  typeof arg === "undefined";
}
function isBuffer(arg) {
  return arg instanceof Buffer;
}
function objectToString(o) {
  return Object.prototype.toString.call(o);
}
function pad(n) {
  return n < 10 ? "0" + n.toString(10) : n.toString(10);
}
var months = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
function timestamp() {
  const d = /* @__PURE__ */ new Date();
  const time = [
    pad(d.getHours()),
    pad(d.getMinutes()),
    pad(d.getSeconds())
  ].join(":");
  return [d.getDate(), months[d.getMonth()], time].join(" ");
}
function log() {
  console.log("%s - %s", timestamp(), format.apply(null, arguments));
}
function inherits(ctor, superCtor) {
  Object.defineProperty(ctor, "super_", {
    value: superCtor,
    writable: true,
    configurable: true
  });
  Object.setPrototypeOf(ctor.prototype, superCtor.prototype);
}
function _extend(origin, add) {
  if (!add || !isObject(add)) return origin;
  const keys = Object.keys(add);
  let i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var kCustomPromisifiedSymbol = Symbol("util.promisify.custom");
function promisify(original) {
  if (typeof original !== "function")
    throw new TypeError('The "original" argument must be of type Function');
  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    const fn2 = original[kCustomPromisifiedSymbol];
    if (typeof fn2 !== "function") {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn2, kCustomPromisifiedSymbol, {
      value: fn2,
      enumerable: false,
      writable: false,
      configurable: true
    });
    return fn2;
  }
  function fn() {
    let promiseResolve, promiseReject;
    const promise = new Promise(function(resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });
    const args = [];
    for (let i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function(err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });
    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }
    return promise;
  }
  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(
    fn,
    Object.getOwnPropertyDescriptors(original)
  );
}
promisify.custom = kCustomPromisifiedSymbol;
function callbackifyOnRejected(reason, cb) {
  if (!reason) {
    const newReason = new Error("Promise was rejected with a falsy value");
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}
function callbackify(original) {
  if (typeof original !== "function") {
    throw new TypeError('The "original" argument must be of type Function');
  }
  function callbackified() {
    const args = [];
    for (let i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    const maybeCb = args.pop();
    if (typeof maybeCb !== "function") {
      throw new TypeError("The last argument must be of type Function");
    }
    const self = this;
    const cb = function() {
      return maybeCb.apply(self, arguments);
    };
    original.apply(this, args).then(
      function(ret) {
        process_default.nextTick(cb.bind(null, null, ret));
      },
      function(rej) {
        process_default.nextTick(callbackifyOnRejected.bind(null, rej, cb));
      }
    );
  }
  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(
    callbackified,
    Object.getOwnPropertyDescriptors(original)
  );
  return callbackified;
}

// node_modules/.pnpm/@frida+assert@3.0.2/node_modules/@frida/assert/internal/errors.js
var codes = {};
function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }
  function getMessage(arg1, arg2, arg3) {
    if (typeof message === "string") {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }
  class NodeError extends Base {
    constructor(arg1, arg2, arg3) {
      super(getMessage(arg1, arg2, arg3));
      this.code = code;
    }
  }
  codes[code] = NodeError;
}
function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    const len = expected.length;
    expected = expected.map((i) => String(i));
    if (len > 2) {
      return \`one of \${thing} \${expected.slice(0, len - 1).join(", ")}, or \` + expected[len - 1];
    } else if (len === 2) {
      return \`one of \${thing} \${expected[0]} or \${expected[1]}\`;
    } else {
      return \`of \${thing} \${expected[0]}\`;
    }
  } else {
    return \`of \${thing} \${String(expected)}\`;
  }
}
function startsWith(str, search, pos) {
  return str.substr(0 , search.length) === search;
}
function endsWith(str, search, this_len) {
  if (this_len === void 0 || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
}
function includes(str, search, start) {
  if (typeof start !== "number") {
    start = 0;
  }
  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}
createErrorType("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError);
createErrorType(
  "ERR_INVALID_ARG_TYPE",
  (name, expected, actual) => {
    let determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    let msg;
    if (endsWith(name, " argument")) {
      msg = \`The \${name} \${determiner} \${oneOf(expected, "type")}\`;
    } else {
      const type = includes(name, ".") ? "property" : "argument";
      msg = \`The "\${name}" \${type} \${determiner} \${oneOf(expected, "type")}\`;
    }
    msg += \`. Received type \${typeof actual}\`;
    return msg;
  },
  TypeError
);
createErrorType("ERR_INVALID_ARG_VALUE", (name, value, reason = "is invalid") => {
  let inspected = util_default.inspect(value);
  if (inspected.length > 128) {
    inspected = \`\${inspected.slice(0, 128)}...\`;
  }
  return \`The argument '\${name}' \${reason}. Received \${inspected}\`;
}, TypeError);
createErrorType("ERR_INVALID_RETURN_VALUE", (input, name, value) => {
  let type;
  if (value && value.constructor && value.constructor.name) {
    type = \`instance of \${value.constructor.name}\`;
  } else {
    type = \`type \${typeof value}\`;
  }
  return \`Expected \${input} to be returned from the "\${name}" function but got \${type}.\`;
}, TypeError);
createErrorType(
  "ERR_MISSING_ARGS",
  (...args) => {
    let msg = "The ";
    const len = args.length;
    args = args.map((a) => \`"\${a}"\`);
    switch (len) {
      case 1:
        msg += \`\${args[0]} argument\`;
        break;
      case 2:
        msg += \`\${args[0]} and \${args[1]} arguments\`;
        break;
      default:
        msg += args.slice(0, len - 1).join(", ");
        msg += \`, and \${args[len - 1]} arguments\`;
        break;
    }
    return \`\${msg} must be specified\`;
  },
  TypeError
);

// node_modules/.pnpm/@frida+assert@3.0.2/node_modules/@frida/assert/internal/assert/assertion_error.js
var {
  ERR_INVALID_ARG_TYPE
} = codes;
function endsWith2(str, search, this_len) {
  if (this_len === void 0 || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
}
function repeat(str, count) {
  count = Math.floor(count);
  if (str.length == 0 || count == 0)
    return "";
  var maxCount = str.length * count;
  count = Math.floor(Math.log(count) / Math.log(2));
  while (count) {
    str += str;
    count--;
  }
  str += str.substring(0, maxCount - str.length);
  return str;
}
var blue = "";
var green = "";
var red = "";
var white = "";
var kReadableOperator = {
  deepStrictEqual: "Expected values to be strictly deep-equal:",
  strictEqual: "Expected values to be strictly equal:",
  strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
  deepEqual: "Expected values to be loosely deep-equal:",
  equal: "Expected values to be loosely equal:",
  notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
  notStrictEqual: 'Expected "actual" to be strictly unequal to:',
  notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
  notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
  notEqual: 'Expected "actual" to be loosely unequal to:',
  notIdentical: "Values identical but not reference-equal:"
};
var kMaxShortLength = 10;
function copyError(source) {
  const keys = Object.keys(source);
  const target = Object.create(Object.getPrototypeOf(source));
  keys.forEach((key) => {
    target[key] = source[key];
  });
  Object.defineProperty(target, "message", { value: source.message });
  return target;
}
function inspectValue(val) {
  return inspect(
    val,
    {
      compact: false,
      customInspect: false,
      depth: 1e3,
      maxArrayLength: Infinity,
      // Assert compares only enumerable properties (with a few exceptions).
      showHidden: false,
      // Having a long line as error is better than wrapping the line for
      // comparison for now.
      // TODO(BridgeAR): \`breakLength\` should be limited as soon as soon as we
      // have meta information about the inspected properties (i.e., know where
      // in what line the property starts and ends).
      breakLength: Infinity,
      // Assert does not detect proxies currently.
      showProxy: false,
      sorted: true,
      // Inspect getters as we also check them when comparing entries.
      getters: true
    }
  );
}
function createErrDiff(actual, expected, operator) {
  let other = "";
  let res = "";
  let lastPos = 0;
  let end = "";
  let skipped = false;
  const actualInspected = inspectValue(actual);
  const actualLines = actualInspected.split("\\n");
  const expectedLines = inspectValue(expected).split("\\n");
  let i = 0;
  let indicator = "";
  if (operator === "strictEqual" && typeof actual === "object" && typeof expected === "object" && actual !== null && expected !== null) {
    operator = "strictEqualObject";
  }
  if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
    const inputLength = actualLines[0].length + expectedLines[0].length;
    if (inputLength <= kMaxShortLength) {
      if ((typeof actual !== "object" || actual === null) && (typeof expected !== "object" || expected === null) && (actual !== 0 || expected !== 0)) {
        return \`\${kReadableOperator[operator]}

\${actualLines[0]} !== \${expectedLines[0]}
\`;
      }
    } else if (operator !== "strictEqualObject") {
      const maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
      if (inputLength < maxLength) {
        while (actualLines[0][i] === expectedLines[0][i]) {
          i++;
        }
        if (i > 2) {
          indicator = \`
  \${repeat(" ", i)}^\`;
          i = 0;
        }
      }
    }
  }
  let a = actualLines[actualLines.length - 1];
  let b = expectedLines[expectedLines.length - 1];
  while (a === b) {
    if (i++ < 2) {
      end = \`
  \${a}\${end}\`;
    } else {
      other = a;
    }
    actualLines.pop();
    expectedLines.pop();
    if (actualLines.length === 0 || expectedLines.length === 0)
      break;
    a = actualLines[actualLines.length - 1];
    b = expectedLines[expectedLines.length - 1];
  }
  const maxLines = Math.max(actualLines.length, expectedLines.length);
  if (maxLines === 0) {
    const actualLines2 = actualInspected.split("\\n");
    if (actualLines2.length > 30) {
      actualLines2[26] = \`\${blue}...\${white}\`;
      while (actualLines2.length > 27) {
        actualLines2.pop();
      }
    }
    return \`\${kReadableOperator.notIdentical}

\${actualLines2.join("\\n")}
\`;
  }
  if (i > 3) {
    end = \`
\${blue}...\${white}\${end}\`;
    skipped = true;
  }
  if (other !== "") {
    end = \`
  \${other}\${end}\`;
    other = "";
  }
  let printedLines = 0;
  const msg = kReadableOperator[operator] + \`
\${green}+ actual\${white} \${red}- expected\${white}\`;
  const skippedMsg = \` \${blue}...\${white} Lines skipped\`;
  for (i = 0; i < maxLines; i++) {
    const cur = i - lastPos;
    if (actualLines.length < i + 1) {
      if (cur > 1 && i > 2) {
        if (cur > 4) {
          res += \`
\${blue}...\${white}\`;
          skipped = true;
        } else if (cur > 3) {
          res += \`
  \${expectedLines[i - 2]}\`;
          printedLines++;
        }
        res += \`
  \${expectedLines[i - 1]}\`;
        printedLines++;
      }
      lastPos = i;
      other += \`
\${red}-\${white} \${expectedLines[i]}\`;
      printedLines++;
    } else if (expectedLines.length < i + 1) {
      if (cur > 1 && i > 2) {
        if (cur > 4) {
          res += \`
\${blue}...\${white}\`;
          skipped = true;
        } else if (cur > 3) {
          res += \`
  \${actualLines[i - 2]}\`;
          printedLines++;
        }
        res += \`
  \${actualLines[i - 1]}\`;
        printedLines++;
      }
      lastPos = i;
      res += \`
\${green}+\${white} \${actualLines[i]}\`;
      printedLines++;
    } else {
      const expectedLine = expectedLines[i];
      let actualLine = actualLines[i];
      let divergingLines = actualLine !== expectedLine && (!endsWith2(actualLine, ",") || actualLine.slice(0, -1) !== expectedLine);
      if (divergingLines && endsWith2(expectedLine, ",") && expectedLine.slice(0, -1) === actualLine) {
        divergingLines = false;
        actualLine += ",";
      }
      if (divergingLines) {
        if (cur > 1 && i > 2) {
          if (cur > 4) {
            res += \`
\${blue}...\${white}\`;
            skipped = true;
          } else if (cur > 3) {
            res += \`
  \${actualLines[i - 2]}\`;
            printedLines++;
          }
          res += \`
  \${actualLines[i - 1]}\`;
          printedLines++;
        }
        lastPos = i;
        res += \`
\${green}+\${white} \${actualLine}\`;
        other += \`
\${red}-\${white} \${expectedLine}\`;
        printedLines += 2;
      } else {
        res += other;
        other = "";
        if (cur === 1 || i === 0) {
          res += \`
  \${actualLine}\`;
          printedLines++;
        }
      }
    }
    if (printedLines > 20 && i < maxLines - 2) {
      return \`\${msg}\${skippedMsg}
\${res}
\${blue}...\${white}\${other}
\${blue}...\${white}\`;
    }
  }
  return \`\${msg}\${skipped ? skippedMsg : ""}
\${res}\${other}\${end}\${indicator}\`;
}
var AssertionError = class extends Error {
  constructor(options) {
    if (typeof options !== "object" || options === null) {
      throw new ERR_INVALID_ARG_TYPE("options", "Object", options);
    }
    const {
      message,
      operator,
      stackStartFn
    } = options;
    let {
      actual,
      expected
    } = options;
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    if (message != null) {
      super(String(message));
    } else {
      if (process.stderr && process.stderr.isTTY) {
        if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
          blue = "\\x1B[34m";
          green = "\\x1B[32m";
          white = "\\x1B[39m";
          red = "\\x1B[31m";
        } else {
          blue = "";
          green = "";
          white = "";
          red = "";
        }
      }
      if (typeof actual === "object" && actual !== null && typeof expected === "object" && expected !== null && "stack" in actual && actual instanceof Error && "stack" in expected && expected instanceof Error) {
        actual = copyError(actual);
        expected = copyError(expected);
      }
      if (operator === "deepStrictEqual" || operator === "strictEqual") {
        super(createErrDiff(actual, expected, operator));
      } else if (operator === "notDeepStrictEqual" || operator === "notStrictEqual") {
        let base = kReadableOperator[operator];
        const res = inspectValue(actual).split("\\n");
        if (operator === "notStrictEqual" && typeof actual === "object" && actual !== null) {
          base = kReadableOperator.notStrictEqualObject;
        }
        if (res.length > 30) {
          res[26] = \`\${blue}...\${white}\`;
          while (res.length > 27) {
            res.pop();
          }
        }
        if (res.length === 1) {
          super(\`\${base} \${res[0]}\`);
        } else {
          super(\`\${base}

\${res.join("\\n")}
\`);
        }
      } else {
        let res = inspectValue(actual);
        let other = "";
        const knownOperators = kReadableOperator[operator];
        if (operator === "notDeepEqual" || operator === "notEqual") {
          res = \`\${kReadableOperator[operator]}

\${res}\`;
          if (res.length > 1024) {
            res = \`\${res.slice(0, 1021)}...\`;
          }
        } else {
          other = \`\${inspectValue(expected)}\`;
          if (res.length > 512) {
            res = \`\${res.slice(0, 509)}...\`;
          }
          if (other.length > 512) {
            other = \`\${other.slice(0, 509)}...\`;
          }
          if (operator === "deepEqual" || operator === "equal") {
            res = \`\${knownOperators}

\${res}

should equal

\`;
          } else {
            other = \` \${operator} \${other}\`;
          }
        }
        super(\`\${res}\${other}\`);
      }
    }
    Error.stackTraceLimit = limit;
    this.generatedMessage = !message;
    Object.defineProperty(this, "name", {
      value: "AssertionError [ERR_ASSERTION]",
      enumerable: false,
      writable: true,
      configurable: true
    });
    this.code = "ERR_ASSERTION";
    this.actual = actual;
    this.expected = expected;
    this.operator = operator;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, stackStartFn);
    }
    this.stack;
    this.name = "AssertionError";
  }
  toString() {
    return \`\${this.name} [\${this.code}]: \${this.message}\`;
  }
  [inspect.custom](recurseTimes, ctx) {
    return inspect(this, { ...ctx, customInspect: false, depth: 0 });
  }
};

// node_modules/.pnpm/@frida+assert@3.0.2/node_modules/@frida/assert/internal/util/comparisons.js
var regexFlagsSupported = /a/g.flags !== void 0;
var arrayFromSet = (set) => {
  const array = [];
  set.forEach((value) => array.push(value));
  return array;
};
var arrayFromMap = (map) => {
  const array = [];
  map.forEach((value, key) => array.push([key, value]));
  return array;
};
function uncurryThis2(f) {
  return f.call.bind(f);
}
var hasOwnProperty2 = uncurryThis2(Object.prototype.hasOwnProperty);
var propertyIsEnumerable = uncurryThis2(Object.prototype.propertyIsEnumerable);
var objectToString2 = uncurryThis2(Object.prototype.toString);
var {
  isAnyArrayBuffer: isAnyArrayBuffer2,
  isArrayBufferView: isArrayBufferView2,
  isDate: isDate2,
  isMap: isMap2,
  isRegExp: isRegExp2,
  isSet: isSet2,
  isNativeError,
  isBoxedPrimitive: isBoxedPrimitive2,
  isNumberObject: isNumberObject2,
  isStringObject: isStringObject2,
  isBooleanObject: isBooleanObject2,
  isBigIntObject: isBigIntObject2,
  isSymbolObject: isSymbolObject2,
  isFloat32Array: isFloat32Array2,
  isFloat64Array: isFloat64Array2
} = types;
function isNonIndex(key) {
  if (key.length === 0 || key.length > 10)
    return true;
  for (var i = 0; i < key.length; i++) {
    const code = key.charCodeAt(i);
    if (code < 48 || code > 57)
      return true;
  }
  return key.length === 10 && key >= 2 ** 32;
}
function getOwnNonIndexProperties(value) {
  return Object.keys(value).filter(isNonIndex).concat(
    Object.getOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value))
  );
}
function compare(a, b) {
  if (a === b) {
    return 0;
  }
  var x = a.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }
  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
var kStrict = true;
var kLoose = false;
var kNoIterator = 0;
var kIsArray = 1;
var kIsSet = 2;
var kIsMap = 3;
function areSimilarRegExps(a, b) {
  return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
}
function areSimilarFloatArrays(a, b) {
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (var offset = 0; offset < a.byteLength; offset++) {
    if (a[offset] !== b[offset]) {
      return false;
    }
  }
  return true;
}
function areSimilarTypedArrays(a, b) {
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  return compare(
    new Uint8Array(a.buffer, a.byteOffset, a.byteLength),
    new Uint8Array(b.buffer, b.byteOffset, b.byteLength)
  ) === 0;
}
function areEqualArrayBuffers(buf1, buf2) {
  return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}
function isEqualBoxedPrimitive(val1, val2) {
  if (isNumberObject2(val1)) {
    return isNumberObject2(val2) && Object.is(
      Number.prototype.valueOf.call(val1),
      Number.prototype.valueOf.call(val2)
    );
  }
  if (isStringObject2(val1)) {
    return isStringObject2(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
  }
  if (isBooleanObject2(val1)) {
    return isBooleanObject2(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
  }
  if (isBigIntObject2(val1)) {
    return isBigIntObject2(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
  }
  return isSymbolObject2(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
}
function innerDeepEqual(val1, val2, strict2, memos) {
  if (val1 === val2) {
    if (val1 !== 0)
      return true;
    return strict2 ? Object.is(val1, val2) : true;
  }
  if (strict2) {
    if (typeof val1 !== "object") {
      return typeof val1 === "number" && Number.isNaN(val1) && Number.isNaN(val2);
    }
    if (typeof val2 !== "object" || val1 === null || val2 === null) {
      return false;
    }
    if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
      return false;
    }
  } else {
    if (val1 === null || typeof val1 !== "object") {
      if (val2 === null || typeof val2 !== "object") {
        return val1 == val2;
      }
      return false;
    }
    if (val2 === null || typeof val2 !== "object") {
      return false;
    }
  }
  const val1Tag = objectToString2(val1);
  const val2Tag = objectToString2(val2);
  if (val1Tag !== val2Tag) {
    return false;
  }
  if (Array.isArray(val1)) {
    if (val1.length !== val2.length) {
      return false;
    }
    const keys1 = getOwnNonIndexProperties(val1);
    const keys2 = getOwnNonIndexProperties(val2);
    if (keys1.length !== keys2.length) {
      return false;
    }
    return keyCheck(val1, val2, strict2, memos, kIsArray, keys1);
  }
  if (val1Tag === "[object Object]") {
    if (!isMap2(val1) && isMap2(val2) || !isSet2(val1) && isSet2(val2)) {
      return false;
    }
  }
  if (isDate2(val1)) {
    if (!isDate2(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
      return false;
    }
  } else if (isRegExp2(val1)) {
    if (!isRegExp2(val2) || !areSimilarRegExps(val1, val2)) {
      return false;
    }
  } else if (isNativeError(val1) || val1 instanceof Error) {
    if (val1.message !== val2.message || val1.name !== val2.name) {
      return false;
    }
  } else if (isArrayBufferView2(val1)) {
    if (!strict2 && (isFloat32Array2(val1) || isFloat64Array2(val1))) {
      if (!areSimilarFloatArrays(val1, val2)) {
        return false;
      }
    } else if (!areSimilarTypedArrays(val1, val2)) {
      return false;
    }
    const keys1 = getOwnNonIndexProperties(val1);
    const keys2 = getOwnNonIndexProperties(val2);
    if (keys1.length !== keys2.length) {
      return false;
    }
    return keyCheck(val1, val2, strict2, memos, kNoIterator, keys1);
  } else if (isSet2(val1)) {
    if (!isSet2(val2) || val1.size !== val2.size) {
      return false;
    }
    return keyCheck(val1, val2, strict2, memos, kIsSet);
  } else if (isMap2(val1)) {
    if (!isMap2(val2) || val1.size !== val2.size) {
      return false;
    }
    return keyCheck(val1, val2, strict2, memos, kIsMap);
  } else if (isAnyArrayBuffer2(val1)) {
    if (!areEqualArrayBuffers(val1, val2)) {
      return false;
    }
  } else if (isBoxedPrimitive2(val1) && !isEqualBoxedPrimitive(val1, val2)) {
    return false;
  }
  return keyCheck(val1, val2, strict2, memos, kNoIterator);
}
function getEnumerables(val, keys) {
  return keys.filter((k) => propertyIsEnumerable(val, k));
}
function keyCheck(val1, val2, strict2, memos, iterationType, aKeys) {
  if (arguments.length === 5) {
    aKeys = Object.keys(val1);
    const bKeys = Object.keys(val2);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
  }
  let i = 0;
  for (; i < aKeys.length; i++) {
    if (!hasOwnProperty2(val2, aKeys[i])) {
      return false;
    }
  }
  if (strict2 && arguments.length === 5) {
    const symbolKeysA = Object.getOwnPropertySymbols(val1);
    if (symbolKeysA.length !== 0) {
      let count = 0;
      for (i = 0; i < symbolKeysA.length; i++) {
        const key = symbolKeysA[i];
        if (propertyIsEnumerable(val1, key)) {
          if (!propertyIsEnumerable(val2, key)) {
            return false;
          }
          aKeys.push(key);
          count++;
        } else if (propertyIsEnumerable(val2, key)) {
          return false;
        }
      }
      const symbolKeysB = Object.getOwnPropertySymbols(val2);
      if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
        return false;
      }
    } else {
      const symbolKeysB = Object.getOwnPropertySymbols(val2);
      if (symbolKeysB.length !== 0 && getEnumerables(val2, symbolKeysB).length !== 0) {
        return false;
      }
    }
  }
  if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
    return true;
  }
  if (memos === void 0) {
    memos = {
      val1: /* @__PURE__ */ new Map(),
      val2: /* @__PURE__ */ new Map(),
      position: 0
    };
  } else {
    const val2MemoA = memos.val1.get(val1);
    if (val2MemoA !== void 0) {
      const val2MemoB = memos.val2.get(val2);
      if (val2MemoB !== void 0) {
        return val2MemoA === val2MemoB;
      }
    }
    memos.position++;
  }
  memos.val1.set(val1, memos.position);
  memos.val2.set(val2, memos.position);
  const areEq = objEquiv(val1, val2, strict2, aKeys, memos, iterationType);
  memos.val1.delete(val1);
  memos.val2.delete(val2);
  return areEq;
}
function setHasEqualElement(set, val1, strict2, memo) {
  const setValues = arrayFromSet(set);
  for (let i = 0; i < setValues.length; i++) {
    const val2 = setValues[i];
    if (innerDeepEqual(val1, val2, strict2, memo)) {
      set.delete(val2);
      return true;
    }
  }
  return false;
}
function findLooseMatchingPrimitives(prim) {
  switch (typeof prim) {
    case "undefined":
      return null;
    case "object":
      return void 0;
    case "symbol":
      return false;
    case "string":
      prim = +prim;
    // Loose equal entries exist only if the string is possible to convert to
    // a regular number and not NaN.
    // Fall through
    case "number":
      if (Number.isNaN(prim)) {
        return false;
      }
  }
  return true;
}
function setMightHaveLoosePrim(a, b, prim) {
  const altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null)
    return altValue;
  return b.has(altValue) && !a.has(altValue);
}
function mapMightHaveLoosePrim(a, b, prim, item, memo) {
  const altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null) {
    return altValue;
  }
  const curB = b.get(altValue);
  if (curB === void 0 && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
    return false;
  }
  return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
}
function setEquiv(a, b, strict2, memo) {
  let set = null;
  const aValues = arrayFromSet(a);
  for (let i = 0; i < aValues.length; i++) {
    const val = aValues[i];
    if (typeof val === "object" && val !== null) {
      if (set === null) {
        set = /* @__PURE__ */ new Set();
      }
      set.add(val);
    } else if (!b.has(val)) {
      if (strict2)
        return false;
      if (!setMightHaveLoosePrim(a, b, val)) {
        return false;
      }
      if (set === null) {
        set = /* @__PURE__ */ new Set();
      }
      set.add(val);
    }
  }
  if (set !== null) {
    const bValues = arrayFromSet(b);
    for (let i = 0; i < bValues.length; i++) {
      const val = bValues[i];
      if (typeof val === "object" && val !== null) {
        if (!setHasEqualElement(set, val, strict2, memo))
          return false;
      } else if (!strict2 && !a.has(val) && !setHasEqualElement(set, val, strict2, memo)) {
        return false;
      }
    }
    return set.size === 0;
  }
  return true;
}
function mapHasEqualEntry(set, map, key1, item1, strict2, memo) {
  const setValues = arrayFromSet(set);
  for (let i = 0; i < setValues.length; i++) {
    const key2 = setValues[i];
    if (innerDeepEqual(key1, key2, strict2, memo) && innerDeepEqual(item1, map.get(key2), strict2, memo)) {
      set.delete(key2);
      return true;
    }
  }
  return false;
}
function mapEquiv(a, b, strict2, memo) {
  let set = null;
  const aEntries = arrayFromMap(a);
  for (let i = 0; i < aEntries.length; i++) {
    const [key, item1] = aEntries[i];
    if (typeof key === "object" && key !== null) {
      if (set === null) {
        set = /* @__PURE__ */ new Set();
      }
      set.add(key);
    } else {
      const item2 = b.get(key);
      if (item2 === void 0 && !b.has(key) || !innerDeepEqual(item1, item2, strict2, memo)) {
        if (strict2)
          return false;
        if (!mapMightHaveLoosePrim(a, b, key, item1, memo))
          return false;
        if (set === null) {
          set = /* @__PURE__ */ new Set();
        }
        set.add(key);
      }
    }
  }
  if (set !== null) {
    const bEntries = arrayFromMap(b);
    for (let i = 0; i < bEntries.length; i++) {
      const [key, item] = bEntries[i];
      if (typeof key === "object" && key !== null) {
        if (!mapHasEqualEntry(set, a, key, item, strict2, memo))
          return false;
      } else if (!strict2 && (!a.has(key) || !innerDeepEqual(a.get(key), item, false, memo)) && !mapHasEqualEntry(set, a, key, item, false, memo)) {
        return false;
      }
    }
    return set.size === 0;
  }
  return true;
}
function objEquiv(a, b, strict2, keys, memos, iterationType) {
  let i = 0;
  if (iterationType === kIsSet) {
    if (!setEquiv(a, b, strict2, memos)) {
      return false;
    }
  } else if (iterationType === kIsMap) {
    if (!mapEquiv(a, b, strict2, memos)) {
      return false;
    }
  } else if (iterationType === kIsArray) {
    for (; i < a.length; i++) {
      if (hasOwnProperty2(a, i)) {
        if (!hasOwnProperty2(b, i) || !innerDeepEqual(a[i], b[i], strict2, memos)) {
          return false;
        }
      } else if (hasOwnProperty2(b, i)) {
        return false;
      } else {
        const keysA = Object.keys(a);
        for (; i < keysA.length; i++) {
          const key = keysA[i];
          if (!hasOwnProperty2(b, key) || !innerDeepEqual(a[key], b[key], strict2, memos)) {
            return false;
          }
        }
        if (keysA.length !== Object.keys(b).length) {
          return false;
        }
        return true;
      }
    }
  }
  for (i = 0; i < keys.length; i++) {
    const key = keys[i];
    if (!innerDeepEqual(a[key], b[key], strict2, memos)) {
      return false;
    }
  }
  return true;
}
function isDeepEqual(val1, val2) {
  return innerDeepEqual(val1, val2, kLoose);
}
function isDeepStrictEqual(val1, val2) {
  return innerDeepEqual(val1, val2, kStrict);
}

// node_modules/.pnpm/@frida+assert@3.0.2/node_modules/@frida/assert/assert.js
var {
  ERR_AMBIGUOUS_ARGUMENT,
  ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
  ERR_INVALID_ARG_VALUE,
  ERR_INVALID_RETURN_VALUE,
  ERR_MISSING_ARGS
} = codes;
var { isPromise: isPromise2, isRegExp: isRegExp3 } = types;
var warned = false;
var assert = ok;
var assert_default = assert;
var NO_EXCEPTION_SENTINEL = {};
function innerFail(obj) {
  if (obj.message instanceof Error) throw obj.message;
  throw new AssertionError(obj);
}
function fail(actual, expected, message, operator, stackStartFn) {
  const argsLen = arguments.length;
  let internalMessage;
  if (argsLen === 0) {
    internalMessage = "Failed";
  } else if (argsLen === 1) {
    message = actual;
    actual = void 0;
  } else {
    if (warned === false) {
      warned = true;
      const warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
      warn(
        "assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.",
        "DeprecationWarning",
        "DEP0094"
      );
    }
    if (argsLen === 2)
      operator = "!=";
  }
  if (message instanceof Error) throw message;
  const errArgs = {
    actual,
    expected,
    operator: operator === void 0 ? "fail" : operator,
    stackStartFn: stackStartFn || fail
  };
  if (message !== void 0) {
    errArgs.message = message;
  }
  const err = new AssertionError(errArgs);
  if (internalMessage) {
    err.message = internalMessage;
    err.generatedMessage = true;
  }
  throw err;
}
assert.fail = fail;
assert.AssertionError = AssertionError;
function innerOk(fn, argLen, value, message) {
  if (!value) {
    let generatedMessage = false;
    if (argLen === 0) {
      generatedMessage = true;
      message = "No value argument passed to \`assert.ok()\`";
    } else if (message instanceof Error) {
      throw message;
    }
    const err = new AssertionError({
      actual: value,
      expected: true,
      message,
      operator: "==",
      stackStartFn: fn
    });
    err.generatedMessage = generatedMessage;
    throw err;
  }
}
function ok(...args) {
  innerOk(ok, args.length, ...args);
}
assert.ok = ok;
assert.equal = function equal(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS("actual", "expected");
  }
  if (actual != expected) {
    innerFail({
      actual,
      expected,
      message,
      operator: "==",
      stackStartFn: equal
    });
  }
};
assert.notEqual = function notEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS("actual", "expected");
  }
  if (actual == expected) {
    innerFail({
      actual,
      expected,
      message,
      operator: "!=",
      stackStartFn: notEqual
    });
  }
};
assert.deepEqual = function deepEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS("actual", "expected");
  }
  if (!isDeepEqual(actual, expected)) {
    innerFail({
      actual,
      expected,
      message,
      operator: "deepEqual",
      stackStartFn: deepEqual
    });
  }
};
assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS("actual", "expected");
  }
  if (isDeepEqual(actual, expected)) {
    innerFail({
      actual,
      expected,
      message,
      operator: "notDeepEqual",
      stackStartFn: notDeepEqual
    });
  }
};
assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS("actual", "expected");
  }
  if (!isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual,
      expected,
      message,
      operator: "deepStrictEqual",
      stackStartFn: deepStrictEqual
    });
  }
};
assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS("actual", "expected");
  }
  if (isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual,
      expected,
      message,
      operator: "notDeepStrictEqual",
      stackStartFn: notDeepStrictEqual
    });
  }
}
assert.strictEqual = function strictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS("actual", "expected");
  }
  if (!Object.is(actual, expected)) {
    innerFail({
      actual,
      expected,
      message,
      operator: "strictEqual",
      stackStartFn: strictEqual
    });
  }
};
assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS("actual", "expected");
  }
  if (Object.is(actual, expected)) {
    innerFail({
      actual,
      expected,
      message,
      operator: "notStrictEqual",
      stackStartFn: notStrictEqual
    });
  }
};
var Comparison = class {
  constructor(obj, keys, actual) {
    keys.forEach((key) => {
      if (key in obj) {
        if (actual !== void 0 && typeof actual[key] === "string" && isRegExp3(obj[key]) && obj[key].test(actual[key])) {
          this[key] = actual[key];
        } else {
          this[key] = obj[key];
        }
      }
    });
  }
};
function compareExceptionKey(actual, expected, key, message, keys, fn) {
  if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
    if (!message) {
      const a = new Comparison(actual, keys);
      const b = new Comparison(expected, keys, actual);
      const err = new AssertionError({
        actual: a,
        expected: b,
        operator: "deepStrictEqual",
        stackStartFn: fn
      });
      err.actual = actual;
      err.expected = expected;
      err.operator = fn.name;
      throw err;
    }
    innerFail({
      actual,
      expected,
      message,
      operator: fn.name,
      stackStartFn: fn
    });
  }
}
function expectedException(actual, expected, msg, fn) {
  if (typeof expected !== "function") {
    if (isRegExp3(expected))
      return expected.test(actual);
    if (arguments.length === 2) {
      throw new ERR_INVALID_ARG_TYPE2(
        "expected",
        ["Function", "RegExp"],
        expected
      );
    }
    if (typeof actual !== "object" || actual === null) {
      const err = new AssertionError({
        actual,
        expected,
        message: msg,
        operator: "deepStrictEqual",
        stackStartFn: fn
      });
      err.operator = fn.name;
      throw err;
    }
    const keys = Object.keys(expected);
    if (expected instanceof Error) {
      keys.push("name", "message");
    } else if (keys.length === 0) {
      throw new ERR_INVALID_ARG_VALUE(
        "error",
        expected,
        "may not be an empty object"
      );
    }
    keys.forEach((key) => {
      if (typeof actual[key] === "string" && isRegExp3(expected[key]) && expected[key].test(actual[key])) {
        return;
      }
      compareExceptionKey(actual, expected, key, msg, keys, fn);
    });
    return true;
  }
  if (expected.prototype !== void 0 && actual instanceof expected) {
    return true;
  }
  if (Error.isPrototypeOf(expected)) {
    return false;
  }
  return expected.call({}, actual) === true;
}
function getActual(fn) {
  if (typeof fn !== "function") {
    throw new ERR_INVALID_ARG_TYPE2("fn", "Function", fn);
  }
  try {
    fn();
  } catch (e) {
    return e;
  }
  return NO_EXCEPTION_SENTINEL;
}
function checkIsPromise(obj) {
  return isPromise2(obj) || obj !== null && typeof obj === "object" && typeof obj.then === "function" && typeof obj.catch === "function";
}
function waitForActual(promiseFn) {
  return Promise.resolve().then(() => {
    let resultPromise;
    if (typeof promiseFn === "function") {
      resultPromise = promiseFn();
      if (!checkIsPromise(resultPromise)) {
        throw new ERR_INVALID_RETURN_VALUE(
          "instance of Promise",
          "promiseFn",
          resultPromise
        );
      }
    } else if (checkIsPromise(promiseFn)) {
      resultPromise = promiseFn;
    } else {
      throw new ERR_INVALID_ARG_TYPE2("promiseFn", ["Function", "Promise"], promiseFn);
    }
    return Promise.resolve().then(() => resultPromise).then(() => NO_EXCEPTION_SENTINEL).catch((e) => e);
  });
}
function expectsError(stackStartFn, actual, error, message) {
  if (typeof error === "string") {
    if (arguments.length === 4) {
      throw new ERR_INVALID_ARG_TYPE2(
        "error",
        ["Object", "Error", "Function", "RegExp"],
        error
      );
    }
    if (typeof actual === "object" && actual !== null) {
      if (actual.message === error) {
        throw new ERR_AMBIGUOUS_ARGUMENT(
          "error/message",
          \`The error message "\${actual.message}" is identical to the message.\`
        );
      }
    } else if (actual === error) {
      throw new ERR_AMBIGUOUS_ARGUMENT(
        "error/message",
        \`The error "\${actual}" is identical to the message.\`
      );
    }
    message = error;
    error = void 0;
  } else if (error != null && typeof error !== "object" && typeof error !== "function") {
    throw new ERR_INVALID_ARG_TYPE2(
      "error",
      ["Object", "Error", "Function", "RegExp"],
      error
    );
  }
  if (actual === NO_EXCEPTION_SENTINEL) {
    let details = "";
    if (error && error.name) {
      details += \` (\${error.name})\`;
    }
    details += message ? \`: \${message}\` : ".";
    const fnType = stackStartFn.name === "rejects" ? "rejection" : "exception";
    innerFail({
      actual: void 0,
      expected: error,
      operator: stackStartFn.name,
      message: \`Missing expected \${fnType}\${details}\`,
      stackStartFn
    });
  }
  if (error && !expectedException(actual, error, message, stackStartFn)) {
    throw actual;
  }
}
function expectsNoError(stackStartFn, actual, error, message) {
  if (actual === NO_EXCEPTION_SENTINEL)
    return;
  if (typeof error === "string") {
    message = error;
    error = void 0;
  }
  if (!error || expectedException(actual, error)) {
    const details = message ? \`: \${message}\` : ".";
    const fnType = stackStartFn.name === "doesNotReject" ? "rejection" : "exception";
    innerFail({
      actual,
      expected: error,
      operator: stackStartFn.name,
      message: \`Got unwanted \${fnType}\${details}
Actual message: "\${actual && actual.message}"\`,
      stackStartFn
    });
  }
  throw actual;
}
assert.throws = function throws(promiseFn, ...args) {
  expectsError(throws, getActual(promiseFn), ...args);
};
assert.rejects = function rejects(promiseFn, ...args) {
  return waitForActual(promiseFn).then((result) => {
    return expectsError(rejects, result, ...args);
  });
};
assert.doesNotThrow = function doesNotThrow(fn, ...args) {
  expectsNoError(doesNotThrow, getActual(fn), ...args);
};
assert.doesNotReject = function doesNotReject(fn, ...args) {
  return waitForActual(fn).then((result) => {
    return expectsNoError(doesNotReject, result, ...args);
  });
};
assert.ifError = function ifError(err) {
  if (err !== null && err !== void 0) {
    let message = "ifError got unwanted exception: ";
    if (typeof err === "object" && typeof err.message === "string") {
      if (err.message.length === 0 && err.constructor) {
        message += err.constructor.name;
      } else {
        message += err.message;
      }
    } else {
      message += inspect(err);
    }
    const newErr = new AssertionError({
      actual: err,
      expected: null,
      operator: "ifError",
      message,
      stackStartFn: ifError
    });
    const origStack = err.stack;
    if (typeof origStack === "string") {
      const tmp2 = origStack.split("\\n");
      tmp2.shift();
      let tmp1 = newErr.stack.split("\\n");
      for (var i = 0; i < tmp2.length; i++) {
        const pos = tmp1.indexOf(tmp2[i]);
        if (pos !== -1) {
          tmp1 = tmp1.slice(0, pos);
          break;
        }
      }
      newErr.stack = \`\${tmp1.join("\\n")}
\${tmp2.join("\\n")}\`;
    }
    throw newErr;
  }
};
function strict(...args) {
  innerOk(strict, args.length, ...args);
}
assert.strict = Object.assign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

// packages/frida-compile/frida/agent1/main.ts
assert_default(true, "1 should be equal to 1");
/*! Bundled license information:

@frida/assert/internal/util/comparisons.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)
*/
"
`;
